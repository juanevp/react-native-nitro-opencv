///
/// HybridImageFilteringSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `HybridCvMatSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvMatSpec; }
// Forward declaration of `BorderTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class BorderTypes; }
// Forward declaration of `HybridCvSizeSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvSizeSpec; }
// Forward declaration of `HybridCvPointSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvPointSpec; }
// Forward declaration of `DataTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class DataTypes; }
// Forward declaration of `HybridCvScalarSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvScalarSpec; }
// Forward declaration of `MorphShapes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class MorphShapes; }
// Forward declaration of `MorphTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class MorphTypes; }

#include <memory>
#include "HybridCvMatSpec.hpp"
#include "BorderTypes.hpp"
#include "HybridCvSizeSpec.hpp"
#include "HybridCvPointSpec.hpp"
#include "DataTypes.hpp"
#include "HybridCvScalarSpec.hpp"
#include <optional>
#include "MorphShapes.hpp"
#include "MorphTypes.hpp"

namespace margelo::nitro::nitroopencv {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `ImageFiltering`
   * Inherit this class to create instances of `HybridImageFilteringSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridImageFiltering: public HybridImageFilteringSpec {
   * public:
   *   HybridImageFiltering(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridImageFilteringSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridImageFilteringSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridImageFilteringSpec() override = default;

    public:
      // Properties
      

    public:
      // Methods
      virtual void bilateralFilter(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double d, double sigmaColor, double sigmaSpace, BorderTypes borderType) = 0;
      virtual void blur(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvSizeSpec>& ksize, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>& anchor, BorderTypes borderType) = 0;
      virtual void boxFilter(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DataTypes ddepth, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvSizeSpec>& ksize, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>& anchor, bool normalize, BorderTypes borderType) = 0;
      virtual void buildPyramid(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double maxlevel, BorderTypes borderType) = 0;
      virtual void dilate(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& kernel, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>& anchor, double iterations, BorderTypes borderType, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec>& borderValue) = 0;
      virtual void erode(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& kernel, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>& anchor, double iterations, BorderTypes borderType, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec>& borderValue) = 0;
      virtual void filter2D(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double ddepth, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& kernel, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>& anchor, double delat, BorderTypes borderType) = 0;
      virtual void GaussianBlur(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvSizeSpec>& ksize, double sigmaX, std::optional<double> sigmaY, std::optional<BorderTypes> borderType) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec> getGaborKernel(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvSizeSpec>& ksize, double sigma, double theta, double lambd, double gamma, double psi, DataTypes ktype) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec> getGaussianKernel(double ksize, double sigma, DataTypes ktype) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec> getStructuringElement(MorphShapes shape, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvSizeSpec>& ksize, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>>& anchor) = 0;
      virtual void Laplacian(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DataTypes ddepth, double ksize, double scale, double delta, BorderTypes borderType) = 0;
      virtual void medianBlur(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double ksize) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec> morphologyDefaultBorderValue() = 0;
      virtual void morphologyEx(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, MorphTypes op, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& kernel, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>>& anchor, std::optional<double> iterations, std::optional<BorderTypes> borderType, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec>>& borderValue) = 0;
      virtual void Sobel(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double ddepth, double dx, double dy, double ksize, double scale, double delta, BorderTypes borderType) = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "ImageFiltering";
  };

} // namespace margelo::nitro::nitroopencv
