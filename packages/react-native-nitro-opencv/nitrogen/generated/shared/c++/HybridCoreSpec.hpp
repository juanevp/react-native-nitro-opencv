///
/// HybridCoreSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `HybridCvMatSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvMatSpec; }
// Forward declaration of `DataTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class DataTypes; }
// Forward declaration of `NormTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class NormTypes; }
// Forward declaration of `BorderTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class BorderTypes; }
// Forward declaration of `HybridMatVectorSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridMatVectorSpec; }
// Forward declaration of `CovarFlags` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class CovarFlags; }
// Forward declaration of `HybridCvPointSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvPointSpec; }
// Forward declaration of `CmpTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class CmpTypes; }
// Forward declaration of `HybridCvScalarSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvScalarSpec; }
// Forward declaration of `HybridCvRectSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvRectSpec; }
// Forward declaration of `DftFlags` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class DftFlags; }
// Forward declaration of `HybridPointVectorSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridPointVectorSpec; }
// Forward declaration of `GemmFlags` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class GemmFlags; }
// Forward declaration of `HybridCvPoint2fSpec` to properly resolve imports.
namespace margelo::nitro::nitroopencv { class HybridCvPoint2fSpec; }
// Forward declaration of `DecompTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class DecompTypes; }
// Forward declaration of `ReduceTypes` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class ReduceTypes; }
// Forward declaration of `RotateFlags` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class RotateFlags; }
// Forward declaration of `SortFlags` to properly resolve imports.
namespace margelo::nitro::nitroopencv { enum class SortFlags; }

#include <memory>
#include "HybridCvMatSpec.hpp"
#include <optional>
#include "DataTypes.hpp"
#include "NormTypes.hpp"
#include "BorderTypes.hpp"
#include "HybridMatVectorSpec.hpp"
#include "CovarFlags.hpp"
#include <variant>
#include "HybridCvPointSpec.hpp"
#include "CmpTypes.hpp"
#include "HybridCvScalarSpec.hpp"
#include "HybridCvRectSpec.hpp"
#include "DftFlags.hpp"
#include "HybridPointVectorSpec.hpp"
#include "GemmFlags.hpp"
#include "HybridCvPoint2fSpec.hpp"
#include "DecompTypes.hpp"
#include <tuple>
#include "ReduceTypes.hpp"
#include "RotateFlags.hpp"
#include "SortFlags.hpp"

namespace margelo::nitro::nitroopencv {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `Core`
   * Inherit this class to create instances of `HybridCoreSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridCore: public HybridCoreSpec {
   * public:
   *   HybridCore(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridCoreSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridCoreSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridCoreSpec() override = default;

    public:
      // Properties
      

    public:
      // Methods
      virtual void absdiff(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void add(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask, std::optional<DataTypes> dtype) = 0;
      virtual void addWeighted(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, double alpha, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, double beta, double gamma, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, std::optional<DataTypes> dtype) = 0;
      virtual void batchDistance(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dist, double dtype, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& nidx, NormTypes normType, double K, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& mask, double update, bool crosscheck) = 0;
      virtual void bitwise_and(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void bitwise_not(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void bitwise_or(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void bitwise_xor(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual double borderInterpolate(double p, double len, BorderTypes borderType) = 0;
      virtual void calcCovarMatrix(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& samples, double nsamples, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& covar, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& mean, CovarFlags flags, DataTypes ctype) = 0;
      virtual void cartToPolar(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& x, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& y, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& magnitude, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& angle, std::optional<bool> angleInDegrees) = 0;
      virtual void cartToPolarN(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& x, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& y, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& magnitude, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& angle, std::optional<bool> angleInDegrees) = 0;
      virtual void checkRange(const std::variant<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>, std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>>& a, bool quiet, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPointSpec>>& pos, double minVal, double maxVal) = 0;
      virtual void compare(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, CmpTypes cmpop) = 0;
      virtual void completeSymm(const std::variant<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>, std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>>& m, bool lowerToUpper) = 0;
      virtual void convertFp16(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void convertScaleAbs(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, std::optional<double> alpha, std::optional<double> beta) = 0;
      virtual void copyMakeBorder(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double top, double bottom, double left, double right, BorderTypes borderType, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec>& value) = 0;
      virtual void copyTo(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& mask) = 0;
      virtual double countNonZero(const std::variant<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>, std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>>& src) = 0;
      virtual void crop(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvRectSpec>& roi) = 0;
      virtual void dct(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DftFlags flags) = 0;
      virtual double determinant(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src) = 0;
      virtual void dft(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DftFlags flags, double nonzeroRows) = 0;
      virtual void divide(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double scale, std::optional<double> dtype) = 0;
      virtual void eigen(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& eigenvalues, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& eigenvectors) = 0;
      virtual void eigenNonSymmetric(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& eigenvalues, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& eigenvectors) = 0;
      virtual void exp(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void extractChannel(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double coi) = 0;
      virtual void findNonZero(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::variant<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>, std::shared_ptr<margelo::nitro::nitroopencv::HybridPointVectorSpec>>& idx) = 0;
      virtual void flip(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double flipCode) = 0;
      virtual void gemm(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, double alpha, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src3, double beta, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, GemmFlags flags) = 0;
      virtual double getOptimalDFTSize(double vecsize) = 0;
      virtual void getRotationMatrix2D(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvPoint2fSpec>& center, double angle, double scale, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void hconcat(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& srcs, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void idft(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DftFlags flags, double nonzeroRows) = 0;
      virtual void inRange(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec>& lowerb, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec>& upperb, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void insertChannel(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double coi) = 0;
      virtual void invert(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DecompTypes flags) = 0;
      virtual void log(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void LUT(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& lut, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void magnitude(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& x, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& y, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& magnitude) = 0;
      virtual void magnitudeN(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& x, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& y, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& magnitude) = 0;
      virtual void Mahalanobis(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& v1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& v2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& icovar) = 0;
      virtual void MahalanobisN(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& v1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& v2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& icovar) = 0;
      virtual void max(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec> mean(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void meanStdDev(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& mean, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& stddev, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void merge(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& mv, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void min(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual std::tuple<double, double> minMaxLoc(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void mulSpectrums(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& a, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& b, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& c, DftFlags flags, std::optional<bool> conjB) = 0;
      virtual void multiply(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double scale, std::optional<DataTypes> dtype) = 0;
      virtual void mulTransposed(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, bool aTa, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& delta, double scale, std::optional<DataTypes> dtype) = 0;
      virtual double norm(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, NormTypes normType, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask) = 0;
      virtual void normalize(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double alpha, NormTypes normType) = 0;
      virtual void patchNaNs(const std::variant<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>, std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>>& a, double val) = 0;
      virtual void perspectiveTransform(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& m) = 0;
      virtual void phase(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& x, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& y, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& angle, bool angleInDegrees) = 0;
      virtual void phaseN(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& x, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& y, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& angle, bool angleInDegrees) = 0;
      virtual void pow(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, double power, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual double PSNR(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, double R) = 0;
      virtual void reduce(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, double dim, ReduceTypes rtype, DataTypes dtype) = 0;
      virtual void repeat(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, double ny, double nx, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void rotate(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, RotateFlags code) = 0;
      virtual void scaleAdd(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, double alpha, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual bool solve(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DecompTypes flags) = 0;
      virtual bool solveCubic(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& coeffs, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& roots) = 0;
      virtual double solvePoly(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, std::optional<double> maxIters) = 0;
      virtual void sort(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, SortFlags flags) = 0;
      virtual void sortIdx(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, SortFlags flags) = 0;
      virtual void split(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& dst) = 0;
      virtual void sqrt(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void subtract(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src1, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src2, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::optional<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>>& mask, std::optional<DataTypes> dtype) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec> sum(const std::variant<std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>, std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>>& src) = 0;
      virtual std::shared_ptr<margelo::nitro::nitroopencv::HybridCvScalarSpec> trace(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& mtx) = 0;
      virtual void transform(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& m) = 0;
      virtual void transpose(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void vconcat(const std::shared_ptr<margelo::nitro::nitroopencv::HybridMatVectorSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst) = 0;
      virtual void convertTo(const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& src, const std::shared_ptr<margelo::nitro::nitroopencv::HybridCvMatSpec>& dst, DataTypes rtype, std::optional<double> alpha, std::optional<double> beta) = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "Core";
  };

} // namespace margelo::nitro::nitroopencv
